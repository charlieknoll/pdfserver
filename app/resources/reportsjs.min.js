(function(undefined){
    // (0, eval)('this') is a robust way of getting a reference to the global object
    // For details, see http://stackoverflow.com/questions/14119988/return-this-0-evalthis/14120023#14120023
    var window = this || (0, eval)('this'),
        document = window['document'],
        navigator = window['navigator'],
        JSON = window["JSON"];

(function (factory) {
    // Support three module loading scenarios
    if (typeof define === 'function' && define['amd']) {
        // [1] AMD anonymous module
        define(['exports', 'require'], factory);
    } else if (typeof exports === 'object' && typeof module === 'object') {
        // [2] CommonJS/Node.js
        factory(module['exports'] || exports);  // module.exports is for Node.js
    } else {
        // [3] No module loader (plain <script> tag) - put directly in global namespace
        factory(window['rp'] = {});
    }
}(function (rp, amdRequire) {

//extensions 
if (!NodeList.prototype.last) {
    NodeList.prototype.last = function () {
        return this[this.length - 1];
    };
}
Node.prototype.deleteChildren = function () {
    while (this.firstChild) {
        this.removeChild(this.firstChild);
    }
};

var rp = rp || {};

rp.version = "0.1.1";
rp.wrapperClass = 'rp-parent';
rp.hidden = {};
rp.hiddenBreakPoints =
    [["a6"],
    ["a5", "a6-ls"],
    ["a4", "a5-ls"],
    ["letter", "legal"],
    ["letter-ls", "tabloid", "ledger-ls"],
    ["a3", "a4-ls"],
    ["legal-ls"],
    ["a2", "a3-ls"],
    ["ledger", "tabloid-ls"],
    ["a1", "a2-ls"],
    ["a0", "a1-ls"],
    ["a0-ls"]];

Options = function (opt) {
  var self = this;
  self.prefix = "rp-";

  var options = {
    showLoading: false,
    showToolbar: true,
    hideSource: true,
    base64EncodeImages: false,
    format: null, // (letter, A4, legal) //TODO Match up with chrome
    orientation: null, //landscape, portrait
    marginLeft: 0.7, // (inches)
    marginTop: 0.7,
    marginRight: 0.7,
    marginBottom: 0.7,
    imageDPI: 96, // (300 for press printing)
    embedFonts: true, //TODO (how do we do this in the browser)
    pageClass: self.prefix + "page",
    fullPageClass: self.prefix + "full-page",
    pageHeaderClass: self.prefix + "page-header",
    hidePageHeadersClass: self.prefix + "hide-page-headers",
    pageFooterClass: self.prefix + "page-footer",
    hidePageFootersClass: self.prefix + "hide-page-footers",
    alignBottomClass: self.prefix + "page-footer",
    groupClass: self.prefix + "group",
    groupHeaderClass: self.prefix + "group-header",
    keepTogetherClass: self.prefix + "keep-together",
    forcePageBreakClass: self.prefix + "force-page-break",
    hideOnFirstPageClass: self.prefix + "hide-on-first-page",
    pageCountClass: self.prefix + "page-count",
    pageNumberClass: self.prefix + "page-number",
    idPageNumberClass: self.prefix + "id-page-number",
    minimumGroupChildren: 1, // (don't print a group header and foot if there is nothing in between)
    pdfRenderingUrl: "render.reportsjs.com",
    renderAuthKey: "",
    fontDelay: 100,
    parseableNodeNames: ["P", "BLOCKQUOTE"],
    keepTogetherNodeNames: ["TR", "THEAD", "TFOOT", "CANVAS"],
    groupNodeNames: ["TABLE", "DL", "DETAILS", "OL", "UL"],
    groupHeaderNodeNames: ["DT", "THEAD", "COLGROUP", "SUMMARY"],
    chromePdfOptionsPropertyName: "RESPONSIVE_PAPER_CHROME_PDF_OPTIONS",
    renderCompletePropertyName: "RESPONSIVE_PAPER_FINISHED"
  };
  //handle chrome pdf type options
  if (opt) {
    if (opt.format) opt.format = opt.format.toLowerCase();
    if (opt.landscape) opt.orientation = "landscape";
    if (opt.landscape === false) opt.orientation = "portrait";
  }
  rp.utils.extend(self, options);
  rp.utils.extend(self, opt);
};
Options.prototype.setPaperType = function (paperClass) {
  var self = this;
  var prefix = self.prefix + "ps-";
  if (paperClass === null) paperClass = prefix + "letter";

  //set orientation from paperClass if not explicity set in options

  if (paperClass.endsWith("-ls") && !self.orientation)
    self.orientation = "landscape";
  if (!self.orientation) self.orientation = "portrait";
  if (paperClass.endsWith("-ls"))
    paperClass = paperClass.substring(0, paperClass.length - 3);

  //set format from paperClass if not explicity set in options

  if (
    paperClass.length > prefix.length &&
    !self.format &&
    paperClass.startsWith(prefix)
  ) {
    self.format = paperClass.split(prefix)[1];
  }
  //if (!self.options.format) self.options.format = "letter";
};
Options.prototype.paperType = function () {
  var self = this;
  var paperType = self.prefix + "ps-" + self.format;
  if (self.orientation == "landscape") paperType += "-ls";
  return paperType;
};
Options.prototype.hiddenCss = function () {
  var self = this;
  var css = "";
  var breakPoint = self.format;
  var found = false;
  if (self.orientation == "landscape") breakPoint += "-ls";
  for (var i = 0; i < rp.hiddenBreakPoints.length; i++) {

    if (!found) {
      rp.hiddenBreakPoints[i].forEach(function (val) {
        if (val === breakPoint) found = true;
      });
    }
    if (found) {
      rp.hiddenBreakPoints[i].forEach(function (val) {
        css += "." + self.prefix + "hidden-" + val + " {display: none} ";
      });
    }
  }
  return css;



}
Options.prototype.chromeOptions = function () {
  var self = this;
  var opt = {};
  opt.format =
    self.format.substring(0, 1).toUpperCase() + self.format.substring(1);
  opt.margin = {};
  opt.margin.top = 0;
  opt.margin.left = 0;
  opt.margin.right = 0;
  opt.margin.bottom = 0;
  opt.marginTop = 0;
  opt.marginLeft = 0;
  opt.marginRight = 0;
  opt.marginBottom = 0;
  opt.landscape = self.orientation === "landscape";
  return opt;
};

rp.utils = {
    //http://youmightnotneedjquery.com/
    extend: function (out) {
        out = out || {};

        for (var i = 1; i < arguments.length; i++) {
            if (!arguments[i])
                continue;

            for (var key in arguments[i]) {
                if (arguments[i].hasOwnProperty(key))
                    out[key] = arguments[i][key];
            }
        }

        return out;
    },
    wrapInner: function wrapInner(parent, wrapper, attribute, attributevalue) {
        if (typeof wrapper === "string") {
            wrapper = document.createElement(wrapper);
        }
        var div = parent.appendChild(wrapper)
            .setAttribute(attribute, attributevalue);

        while (parent.firstChild !== wrapper) {
            wrapper.appendChild(parent.firstChild);
        }
    },
    outerHeight: function (el, includeMargin) {

        var height = el.offsetHeight;
        if (!includeMargin) return height;
        var style = window.getComputedStyle(el);

        height += parseInt(style.marginTop) + parseInt(style.marginBottom);
        return height;
    },
    height: function (el) {
        //Only call after DOM insertion
        var computedStyle = window.getComputedStyle(el, null);
        return parseInt(computedStyle.height) -
            Math.round(parseFloat(computedStyle.paddingTop)) -
            Math.round(parseFloat(computedStyle.paddingBottom));

    },
    clean: function (node, removeComments) {
        var self = this;
        for (var n = 0; n < node.childNodes.length; n++) {
            var child = node.childNodes[n];
            if ((child.nodeType === 8 && removeComments) || (child.nodeType === 3 && !/\S/.test(child.nodeValue))) {
                node.removeChild(child);
                n--;
            }
            else if (child.nodeType === 1) {
                self.clean(child, removeComments);
            }
        }
    },
    nodesToArray: function (nodes) {
        return Array.prototype.slice.call(nodes, 0);
    },
    isDescendant: function (parent, child) {
        var node = child.parentNode;
        while (node != null) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    },
    poll: function (fn, callback, errback, timeout, interval) {
        var endTime = Number(new Date()) + (timeout || 2000);
        interval = interval || 100;

        (function p() {
            // If the condition is met, we're done!
            if (fn()) {
                callback();
            }
            // If the condition isn't met but the timeout hasn't elapsed, go again
            else if (Number(new Date()) < endTime) {
                setTimeout(p, interval);
            }
            // Didn't match and too much time, reject!
            else {
                errback(new Error('timed out for ' + fn + ': ' + arguments));
            }
        })();
    }



};


function Group(element, options) {
  var self = this;
  self.element = element;
  //self.options = options;
  self.headers = [];
  var headerElements = element.getElementsByClassName(options.groupHeaderClass);
  for (var i = 0; i < headerElements.length; i++) {
    //        if (self.element === headerElements[i].parentElement || self.element === headerElements[i].parentElement.parentElement) {
    if (self.element === headerElements[i].parentElement) {
      self.headers.push(headerElements[i].cloneNode(true));
    } else {
      console.log("Error: Found group header which is not direct child of group element")
    }
  }
  self.firstPage = null;
}
Group.prototype.isFirstPage = function (targetPage) {
  //var self = this;
  if (!this.firstPage) return true;
  return this.firstPage.element === targetPage.element;
};

function Page(element, report, isConsolePage, pageBreakPaperType) {
    var self = this;
    self.element = element;
    self.options = report.options;
    self.setPaperType(pageBreakPaperType)
    if (isConsolePage) return

    rp.utils.wrapInner(element, "div", "class", rp.wrapperClass);
    self.innerContent = self.element.childNodes[0];
    //add all page header and page footers
    if (report.pages.length > 0) {
        var wrapper = self.element.childNodes[0];
        var lastPageHeader;
        var i;
        for (i = 0; i < report.headers.length; ++i) {
            lastPageHeader = report.headers[i].cloneNode(true);
            wrapper.insertBefore(lastPageHeader, null);
        }
        self.firstFooter = null;
        for (i = 0; i < report.footers.length; i++) {
            if (i === 0) {
                self.firstFooter = report.footers[i].cloneNode(true);
                wrapper.insertBefore(self.firstFooter, null);
            }
            else {
                wrapper.insertBefore(report.footers[i].cloneNode(true), null);
            }
        }
    }
    else {
        if (report.footers.length > 0) {
            self.firstFooter = report.footers[0];
        }
    }

    self.insertSpacer();

    self.availableHeight = 0.0;

    //This should not use inner height from report, it should use inner height
    //self.innerHeight = report.pageInnerHeight;
    self.innerHeight = rp.utils.height(self.element)


    self.nodesAdded = 0;
}
Page.prototype.setPaperType = function (paperType) {
    var self = this
    if (!self.element.classList.contains(paperType)) {
        self.element.classList.add(paperType)
    }
    self.paperType = paperType
    self.innerHeight = rp.utils.height(self.element);
}
Page.prototype.hasParentOfClass = function (el, className) {
    var self = this;
    if (el.parentElement.classList.contains(className)) return true;
    if (self.element == el) return false;
    return self.hasParentOfClass(el.parentElement, className);

};
Page.prototype.insertSpacer = function () {
    var self = this;
    var wrapper = self.element.childNodes[0];
    var spacer = document.createElement("div");
    spacer.style.height = "0px";
    spacer.innerHTML = "<span style='visibility:hidden;'></span>"; //<!--THIS TRIGGERS CUSTOM FONT LOAD AND ALLOWS FOR ACCURATE SIZING-->
    spacer.classList.add("rp-spacer");
    //spacer.classList.add("rp-parent");
    wrapper.insertBefore(spacer, self.firstFooter);
    self.firstFooter = spacer;
};
Page.prototype.setAvailableHeight = function () {
    var self = this;
    var content = self.element.childNodes[0];
    self.availableHeight = self.innerHeight - rp.utils.outerHeight(content, true);
};
Page.prototype.checkAvailableHeight = function () {
    var self = this;
    self.setAvailableHeight();
    return self.availableHeight > 0;
};

Page.prototype.showElements = function (el, markerClass, stopClass) {
    var self = this;
    for (var i = el.childNodes.length - 1; i > -1; i--) {
        var child = el.childNodes[i];
        if (child.classList && child.classList.contains(markerClass)) {
            child.style.display = 'initial';
        }
        if (child.classList && !child.classList.contains(stopClass)) {
            self.showElements(child, markerClass, stopClass);
        }
    }
};
Page.prototype.deleteElementsByClassName = function (className) {
    var self = this;
    var els = rp.utils.nodesToArray(self.element.getElementsByClassName(className))
    els.forEach(function (el) {
        el.parentNode.removeChild(el)
    })

}
Page.prototype.insertElement = function (parentElement, newElement, referenceElement, isFirstPage) {
    var self = this;


    var newNode = parentElement.insertBefore(newElement, referenceElement);
    if (newNode.classList && newNode.classList.contains(self.options.hidePageHeadersClass)) {

        self.deleteElementsByClassName(self.options.pageHeaderClass)
    }
    if (newNode.classList && newNode.classList.contains(self.options.hidePageFootersClass)) {

        self.deleteElementsByClassName(self.options.pageFooterClass)

    }
    if (newNode.classList && newNode.classList.contains(self.options.fullPageClass)) {

        self.deleteElementsByClassName(self.options.pageFooterClass)
        self.deleteElementsByClassName(self.options.pageHeaderClass)

    }

    if (!isFirstPage) {
        self.showElements(newNode, self.options.hideOnFirstPageClass, self.options.groupClass);
    }
    self.setAvailableHeight();
    self.nodesAdded++;
    return newNode;
};
Page.prototype.removeElement = function (element) {
    var self = this;
    element.parentNode.removeChild(element);
    self.setAvailableHeight();
};


function Report(target, source, opt) {
    //TODO Log warning if group-header has a non group direct parent (in report generation)
    var self = this;
    self.options = new Options(opt);
    self.target = target;
    //add pageClass before scraping canvas


    //TODO validate that all page headers are at same DOM level

    //Allow time for fonts to load
    //TODO maybe do this for each page as it is generated?  This might explain offsets
    // var pause = self.options.fontDelay;
    // if (self.options.showLoading && pause < 500) {
    //     pause = 500;
    // }

    if (!source.className.includes(self.options.pageClass)) {
        source.classList.add(self.options.pageClass);
        console.log("WARNING: The page container class'" + self.options.pageClass + "' was not found on source, responsive elements may not display correctly.");

    }

    // if (self.options.showLoading) {
    //     var loadingDiv = document.createElement('div');
    //     //TODO match page type based on options
    //     loadingDiv.innerHTML = '<div class="' + self.options.pageClass + ' ' + self.options.paperType() + '"><div class="rp-loading"><div></div><div>Generating report...</div></div></div>';
    //     loadingDiv.style.marginBottom = '1000px';
    //     target.parentElement.insertBefore(loadingDiv, target);
    // }

    // target.style.overflow = 'hidden';
    // target.style.maxHeight = '0px';

    //target.style.display = 'none';

    //See if paperType is set on src
    var sourcePaperType = null;
    var prefix = self.options.prefix + 'ps-';
    for (var i = 0; i < source.classList.length; i++) {
        if (source.classList[i].substring(0, prefix.length) == prefix) {
            sourcePaperType = source.classList[i];
        }

    }
    self.options.setPaperType(sourcePaperType);

    var css = self.options.hiddenCss(),
        head = document.head || document.getElementsByTagName('head')[0],
        style = document.createElement('style');

    style.type = 'text/css';
    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
    head.appendChild(style);

    source.classList.remove(sourcePaperType);
    self.defaultPaperType = self.options.paperType()
    source.classList.add(self.defaultPaperType);

    self.blankPageCt = 0;


    self.init(target, source);
    self.generate(true);
    // var el = document.createElement('div');
    // el.style = 'display: none;'
    // el.innerHTML = 'rp-ready-to-print';
    // el.id = 'rp-status';
    // window.document.body.insertBefore(el, window.document.body.firstChild);
    // if (self.options.showLoading) {
    //     target.style.display = '';
    //     loadingDiv.parentElement.removeChild(loadingDiv);
    //     window.scrollBy(0, -window.pageYOffset);
    // }

    window[self.options.chromePdfOptionsPropertyName] = self.options.chromeOptions();
    window[self.options.renderCompletePropertyName] = true;
}
Report.prototype.init = function (target, source) {
    var self = this;
    self.target = target
    var canvasEls = rp.utils.nodesToArray(source.getElementsByTagName("CANVAS"));

    self.canvasObjs = [];
    var i = 0;
    canvasEls.forEach(function (canvasEl) {
        var canvasObj = {};
        //Assign a unique id to support canvas copying later
        if (canvasEl.id === '') {
            canvasEl.id = 'id-rp-' + i++
        }
        canvasObj.id = canvasEl.id;
        canvasObj.el = canvasEl.cloneNode(true);
        canvasObj.el.getContext('2d').drawImage(canvasEl, 0, 0);
        self.canvasObjs.push(canvasObj);
    });


    //var sourceCopy = source.cloneNode(true);
    var pageBreakEls = rp.utils.nodesToArray(source.getElementsByClassName(self.options.forcePageBreakClass));
    pageBreakEls.forEach(function (pageBreakEl) {
        //Iterate through parents setting
        while (source != pageBreakEl.parentNode) {
            pageBreakEl.parentNode.containsPageBreak = true
            pageBreakEl = pageBreakEl.parentNode
        }
    })

    //source.style.display = '';
    //sourceCopy.style.overflow = 'hidden';
    //sourceCopy.style.height = '0px'
    self.initId = source.id;


    //var sourceCopyEl = self.target.insertBefore(sourceCopy, source);
    //if (self.options.hideSource) {
    //source.parentElement.removeChild(source);
    //// source.style.display = 'none';
    //// source.style.overflow = 'hidden';
    //// source.style.height = '0px';
    //}
    self.removeAttributes(source, 'contenteditable');
    // self.convertClass(self.options.prefix + 'hidden-print', self.options.prefix + 'hidden');
    self.options.groupNodeNames.map(function (elName) {
        return self.addClassToElements(source, elName, self.options.groupClass);
    });
    self.options.groupHeaderNodeNames.map(function (elName) {
        return self.addClassToElements(source, elName, self.options.groupHeaderClass);
    });
    self.headers = source.getElementsByClassName(self.options.pageHeaderClass);
    //This forces an additional network request
    // rp.utils.nodesToArray(self.headers).map(function (el) {
    //     rp.utils.nodesToArray(el.childNodes).map(function (cEl) {
    //         self.convertImageTobase64(cEl)
    //     })

    // })
    self.footers = source.getElementsByClassName(self.options.pageFooterClass);
    self.setPageInnerHeight(source);
    self.pages = [];
    self.lastPage = new Page(source, self, false, self.options.paperType());
    self.pages = [self.lastPage];

    self.groups = [];




};
Report.prototype.removeAttributes = function (parent, attributeName) {
    var self = this;
    Array.prototype.slice.call(parent.querySelectorAll('[' + attributeName + ']'), 0).map(function (el) {
        el.removeAttribute(attributeName);
    });

};
// Report.prototype.convertClass = function (existingClassName, newClassName) {
//     var self = this;
//     Array.prototype.slice.call(self.target.lastChild.getElementsByClassName(existingClassName), 0).map(function (el) {
//         el.classList.remove(existingClassName);
//         el.classList.add(newClassName);
//     });

// };
Report.prototype.addDefaultClass = function (el, className) {
    el.classList.add(className);
};
Report.prototype.addClassToElements = function (parentEl, elementName, className) {
    var self = this;
    Array.prototype.slice.call(parentEl.getElementsByTagName(elementName), 0).map(function (el) {
        self.addDefaultClass(el, className);
    });
};
Report.prototype.updateCanvasEls = function () {
    var self = this;
    self.canvasObjs.forEach(function (canvasObj) {
        var el = self.target.querySelector("#" + canvasObj.id);
        if (!el) return;
        el.getContext('2d').drawImage(canvasObj.el, 0, 0);

    });
};
Report.prototype.generate = function (logTime) {
    if (logTime) {
        rp.startTime = new Date().getTime();

    }
    self = this;

    self.splitPages();
    self.updateCanvasEls();
    self.setPageProperties();
    self.alignBottomElements();


    if (logTime) {
        var end = new Date().getTime();
        console.log("Formatting finished in " + (end - rp.startTime) / 1000 + " seconds");
    }
    if (self.options.debug) self.addConsolePage()

};

Report.prototype.alignBottomElements = function () {
    var self = this;
    for (var i = 0; i < self.pages.length; i++) {
        var page = self.pages[i];
        page.setAvailableHeight();
        var alignBottomEls = page.element.getElementsByClassName('rp-spacer');

        if ((page.availableHeight > 0) && (alignBottomEls.length > 0)) {
            var spacer = alignBottomEls[0];
            spacer.style.height = page.availableHeight + 'px';
        }
    }
};

Report.prototype.upsertGroup = function (element, targetPage) {
    var self = this;
    var group = null;
    //see if element is in groups, if not add new group
    for (var i = 0; i < self.groups.length; i++) {
        if (self.groups[i].element === element) {
            group = self.groups[i];
            if (!group.firstPage) group.firstPage = targetPage;
            break;
        }
    }
    if (!group) {
        group = new Group(element, self.options);
        group.firstPage = targetPage;
        self.groups.push(group);
    }
    return group;
};

Report.prototype.setPageProperties = function () {
    var self = this;

    //TODO create Array Map to elements/ids
    var idElementArray = rp.utils.nodesToArray(self.target.getElementsByClassName(self.options.idPageNumberClass)).map(function (el) {
        return {
            el: el,
            id: el.getAttribute('data-id')
        }
    })
    idElementArray = idElementArray.filter(function (o) {
        var target = document.getElementById(o.id)
        if (target) {
            o.target = target
            return o
        }
    })
    for (var i = 1; i <= self.pages.length; i++) {
        var page = self.pages[i - 1];

        var elements = page.element.getElementsByClassName(self.options.pageNumberClass);
        for (var j = 0; j < elements.length; j++) {
            elements[j].innerHTML = i;
        }
        elements = page.element.getElementsByClassName(self.options.pageCountClass);
        for (j = 0; j < elements.length; j++) {
            elements[j].innerHTML = self.pages.length;
        }
        //loop through pageNumberIds and assign pageNumber, pop element if found
        idElementArray = idElementArray.filter(function (o) {
            if (!rp.utils.isDescendant(page.element, o.target)) {
                return o
            }
            o.el.innerHTML = i;
        })

        page.element.id = self.initId + 'Page' + i;
        page.element.style.display = '';

    }
};
Report.prototype.addConsolePage = function () {
    var self = this;
    var newPage = new Page(self.lastPage.element.cloneNode(false), self, true);
    newPage.element.classList.remove(self.defaultPaperType)
    self.pages.push(newPage)
    newPage.setPaperType(self.options.paperType())
    newPage.id = 'rp-console-page'
    //delete new page children
    var header = document.createElement("h1")
    header.innerText = "Console"
    newPage.element.appendChild(header)
    var div = document.createElement("div")
    var msgs = "<ul class='rp-logs'>"
    rp.logs.forEach(function (l) {
        msgs += "<li>" + l + "</li>"
    })
    msgs += "</ul>"
    div.innerHTML = msgs
    newPage.element.appendChild(div)
    self.lastPage.element.parentNode.appendChild(newPage.element)



}
Report.prototype.insertPage = function (pageBreakPaperType) {
    var self = this;
    var newPageEl = self.lastPage.element.cloneNode(false)
    newPageEl.classList.remove(self.defaultPaperType)
    self.defaultPaperType = pageBreakPaperType || self.defaultPaperType
    self.lastPage.element.parentNode.insertBefore(newPageEl, self.lastPage.element);
    var newPage = new Page(newPageEl, self, false, self.defaultPaperType);

    self.pages.splice(self.pages.length - 1, 0, newPage);
    var els, j;
    if (self.pages.length > 2) {
        els = newPage.element.getElementsByClassName(self.options.hideOnFirstPageClass);
        for (j = 0; j < els.length; j++) {
            els[j].classList.remove(self.options.hideOnFirstPageClass);
        }
    }
    if (self.pages.length == 2) {
        els = self.lastPage.element.getElementsByClassName(self.options.hideOnFirstPageClass);
        for (j = 0; j < els.length; j++) {
            if (self.lastPage.hasParentOfClass(els[j], self.options.pageHeaderClass) || self.isPageHeader(els[j])) {
                els[j].classList.remove(self.options.hideOnFirstPageClass);
            }
        }
    }
    newPage.setAvailableHeight();
    return newPage;
};

Report.prototype.isKeepTogetherNode = function (element) {
    var self = this;
    if (self.options.keepTogetherNodeNames.indexOf(element.nodeName) > -1) {
        return true;
    }
    if (!element.classList) return false;
    return element.classList.contains(self.options.keepTogetherClass) ||
        element.classList.contains(self.options.groupHeaderClass) ||
        element.classList.contains(self.options.fullPageClass)
        ;
};
Report.prototype.isParseableNode = function (element) {
    var self = this;
    if (element.nodeType === 3) return true;


    if (self.options.parseableNodeNames.indexOf(element.nodeName) > -1) {
        return true;
    }
    return false;
};

Report.prototype.isPageBand = function (element) {
    if (!element.classList) return false;
    var self = this;
    return element.classList.contains(self.options.pageHeaderClass) ||
        element.classList.contains(self.options.pageFooterClass);
};

Report.prototype.isGroupBand = function (element) {
    if (!element.classList) return false;
    var self = this;
    return element.classList.contains(self.options.groupClass);
};

Report.prototype.isGroupHeader = function (element) {
    if (!element.classList) return false;
    var self = this;
    return element.classList.contains(self.options.groupHeaderClass);
};
Report.prototype.isForcePageBreak = function (element) {
    if (!element.classList) return false;
    var self = this;
    return element.classList.contains(self.options.forcePageBreakClass);
};
Report.prototype.isPageHeader = function (element) {
    if (!element.classList) return false;
    var self = this;
    return element.classList.contains(self.options.pageHeaderClass);
};


Report.prototype.convertImageTobase64 = function (element) {
    //THIS DOESN"T WORK
    if (element.nodeName !== 'IMG') return;
    // var canvas = document.createElement('CANVAS');
    // canvas.height = element.height;
    // canvas.width = element.width;
    // var ctx = canvas.getContext('2d');
    // ctx.drawImage(element, 0, 0);
    // //ctx.drawImage(element)
    // element.src = canvas.toDataURL()
    // //var img = new Image();
    // // img.crossOrigin = 'Anonymous';
    // // img.onload = function (test) {
    // //     canvas.height = img.height;
    // //     canvas.width = img.width;
    // //     ctx.drawImage(img, 0, 0);
    // //     var dataURL = canvas.toDataURL('image/png', 1.0);
    // //     element.src = dataURL;
    // //     canvas = null;
    // // };
    // // img.src = element.src;
};
Report.prototype.splitArray = function (strs, targetPage, newNode, splitPoint, lastDelta) {
    var self = this;
    var lastOffsetHeight = newNode.offsetHeight;
    var lastAvailableHeight = targetPage.availableHeight;
    var targetArray = strs.splice(0, strs.length - splitPoint);
    newNode.lastChild.data = targetArray.join(' ');
    if (lastOffsetHeight != newNode.offsetHeight) targetPage.setAvailableHeight();
    if (targetPage.availableHeight >= 0 && strs.length === 0) return strs;
    if (lastDelta <= 1 && targetPage.availableHeight >= 0 && lastAvailableHeight < 0) return strs;
    var newSplitPoint = 0;
    if (targetPage.availableHeight > 0) {
        newSplitPoint = splitPoint - Math.round((lastDelta) / 2);
    }
    else {

        newSplitPoint = splitPoint + Math.round(lastDelta / 2);
    }
    return self.splitArray(targetArray.concat(strs), targetPage, newNode, newSplitPoint, Math.abs(newSplitPoint - splitPoint));
};
Report.prototype.moveTextBetweenNodesFast = function (newNode, sourceTextNode, targetPage) {
    var self = this;
    if (targetPage.availableHeight < 1) return false;

    var strs = sourceTextNode.textContent.trim().replace(/[\n\r]+/g, '').replace(/\s{2,10}/g, ' ').split(" ");
    var splitPoint = Math.round(strs.length / 2);
    if (newNode.childNodes.length === 0 || newNode.lastChild.nodeType !== 3) newNode.innerHTML = newNode.innerHTML + " ";
    sourceArray = self.splitArray(strs, targetPage, newNode, splitPoint, splitPoint);
    if (sourceArray.length === 0 && targetPage.checkAvailableHeight()) {
        sourceTextNode.parentElement.removeChild(sourceTextNode);
        return false;
    }
    sourceTextNode.data = sourceArray.join(" ");
    return true;
};

Report.prototype.moveTextBetweenNodes = function (newNode, sourceTextNode, targetPage) {
    var strs = sourceTextNode.textContent.trim().replace(/[\n\r]+/g, '').replace(/\s{2,10}/g, ' ').split(" ");
    strs.reverse();
    var offsetHeight = newNode.offsetHeight;
    var lastStr = "";
    if (newNode.childNodes.length === 0 || newNode.lastChild.nodeType !== 3) newNode.innerHTML = newNode.innerHTML + " ";
    while (strs.length > 0 && (offsetHeight === newNode.offsetHeight || targetPage.checkAvailableHeight())) {
        offsetHeight = newNode.offsetHeight;
        lastStr = strs.pop();
        newNode.lastChild.data = newNode.lastChild.data + " " + lastStr;
    }
    if (strs.length === 0 && targetPage.checkAvailableHeight()) {
        sourceTextNode.parentElement.removeChild(sourceTextNode);
        return false;
    }
    //last added string must have triggered overflow so put it back and reset sourceTextNode.inner
    strs.push(lastStr);
    strs.reverse();
    sourceTextNode.data = strs.join(" ");
    newNode.lastChild.data = newNode.lastChild.data.substring(0, newNode.lastChild.data.length - lastStr.length - 1);
    return true;
};

Report.prototype.moveParseableChildNodes = function (targetPage, newNode, sourceNode) {
    var self = this;
    var childNodes = sourceNode.childNodes;
    if (childNodes.length === 0) return false;
    for (var j = 0; j < childNodes.length; j++) {
        var elementToMove = childNodes[j];

        if (elementToMove.nodeType === 3) {
            if (self.moveTextBetweenNodesFast(newNode, elementToMove, targetPage)) return true;


        }
        else {
            newNode.insertBefore(elementToMove.cloneNode(false), null);
            if (!targetPage.checkAvailableHeight()) {
                newNode.removeChild(newNode.lastChild);
                return true;
            }
            if (self.moveParseableChildNodes(targetPage, newNode.lastChild, elementToMove)) return true;
            sourceNode.removeChild(elementToMove);
        }
        --j;
    }
    return false;

};
Report.prototype.shouldPageBreak = function (node) {
    var self = this;
    if (!self.isForcePageBreak(node)) return false;

    // //don't break on first group of report
    // if (self.groups.length === 0 && self.isGroupBand(node)) return false;

    //if the current break element is not the same as the newly added page break node then break.
    if (self.pageBreakElement !== node) {
        self.pageBreakElement = node;
        return true;
    }
    return false;
};


Report.prototype.resetGroupBandSource = function (targetPage, newNode, elementToMove, group) {
    //calc height of non header content
    var self = this;
    var groupNonHeaderHeight = rp.utils.height(newNode);
    //loop through group headers substracting outerHeight of headers with newNode as group parent
    var movedHeaders = newNode.getElementsByClassName(self.options.groupHeaderClass);
    for (j = 0; j < movedHeaders.length; j++) {
        if (movedHeaders[j].parentNode === newNode) {
            groupNonHeaderHeight = groupNonHeaderHeight - rp.utils.outerHeight(movedHeaders[j], true);
        }
    }
    //If none, some or all headers moved
    if (groupNonHeaderHeight === 0) {

        var remainingHeaders = elementToMove.getElementsByClassName(self.options.groupHeaderClass);
        while (remainingHeaders.length > 0) {
            remainingHeaders[0].remove();
        }
        //delete newNode
        targetPage.removeElement(newNode);
        group.firstPage = null;
    }
    //put headers back in source node
    var insertBeforeNode = elementToMove.childNodes[0];
    for (var i = 0; i < group.headers.length; i++) {
        targetPage.insertElement(elementToMove, group.headers[i].cloneNode(true), insertBeforeNode, group.isFirstPage(targetPage));
    }
};

Report.prototype.insertGroupBand = function (targetPage, targetParent, elementToMove, targetReference) {
    var self = this;
    var group = self.upsertGroup(elementToMove, targetPage);

    var newNode = targetPage.insertElement(targetParent,
        elementToMove.cloneNode(false),
        targetReference,
        group.isFirstPage(targetPage));
    if (self.moveChildElements(elementToMove, targetPage, newNode, null, group)) {

        self.resetGroupBandSource(targetPage, newNode, elementToMove, group);

        return true;
    }
    return false;

};

Report.prototype.moveChildElements = function (source, targetPage, targetParent, targetReference, targetGroup) { //returns true if page is full, false if more space
    var self = this;
    var childNodes = source.childNodes;
    if (childNodes.length === 0 && targetPage.availableHeight > 0) return false;
    var newNode;
    var isFirstPage = !targetGroup || (targetGroup.firstPage === targetPage);

    targetPage.insertingElementHTML = source.cloneNode(false).outerHTML
    for (var j = 0; j < childNodes.length; j++) {

        var elementToMove = childNodes[j];

        if (elementToMove.style && elementToMove.style.visibility === "hidden") continue;

        if (self.isPageBand(elementToMove)) continue; //page bands already added to page

        if (self.shouldPageBreak(elementToMove) === true) {
            elementToMove.classList.remove(self.options.forcePageBreakClass)
            targetPage.pageBreak = true
            targetPage.pageBreakPaperType = elementToMove.className == self.options.prefix + 'ps-default' ? self.options.paperType() : elementToMove.className
            return true;

        }

        var isKeepTogetherNode = self.isKeepTogetherNode(elementToMove);

        if (self.isGroupBand(elementToMove) && !isKeepTogetherNode) {

            if (self.insertGroupBand(targetPage, targetParent, elementToMove, targetReference)) return true;

        }
        else { //normal node

            var isParseableNode = self.isParseableNode(elementToMove);

            var childShouldFit = targetPage.availableHeight > (elementToMove.offsetHeight || 0)
                && !elementToMove.containsPageBreak;

            //TODO return false if only headers added
            //if (!childShouldFit && isKeepTogetherNode) return true;
            var elShadow = elementToMove.cloneNode(childShouldFit || isKeepTogetherNode);

            var runningHeight = 0;

            var batchOverflow = false;

            if (!childShouldFit &&
                elementToMove.childNodes.length > 0 &&
                !isParseableNode &&
                !isKeepTogetherNode
            ) {
                //Batch detach before addding to DOM for performance

                var initOffsetHeight = elementToMove.offsetHeight;
                while (elementToMove.childNodes.length > 0 && runningHeight < targetPage.availableHeight && !self.isForcePageBreak(elementToMove.childNodes[0])) {

                    // && (self.isKeepTogetherNode(elementToMove.childNodes[0]))

                    elShadow.insertBefore(elementToMove.removeChild(elementToMove.childNodes[0]), null);
                    runningHeight = initOffsetHeight - elementToMove.offsetHeight;
                    if (runningHeight > targetPage.availableHeight) {
                        elementToMove.insertBefore(elShadow.removeChild(elShadow.lastChild), elementToMove.childNodes[0]);
                        batchOverflow = true;
                    }
                }

            }

            newNode = targetPage.insertElement(targetParent, elShadow, targetReference, isFirstPage);
            if (elShadow.classList && elShadow.classList.contains("rp-contain") && (targetPage.availableHeight < 0)) {
                elShadow.style.maxHeight = (targetPage.availableHeight + (elementToMove.offsetHeight ? elementToMove.offsetHeight : elementToMove.scrollHeight) - 1) + "px";
                targetPage.setAvailableHeight();
            }
            //Check if the elementToMove didn't fit
            //TODO this running height needs to be checked before line above because running height changes after insert element, removed  || !childShouldFit
            if (targetPage.availableHeight < 0 || batchOverflow) {

                //it should have fit but it didn't, remove it and return that the page is full
                if (isKeepTogetherNode || (!isParseableNode && elementToMove.childNodes.length === 0)) {
                    targetPage.removeElement(newNode);
                    targetPage.setAvailableHeight();
                    return true;
                }

                //not a keep together node, delete the children and do them one by one below
                if (newNode.childNodes.length > 0) {
                    if (runningHeight === 0) {
                        newNode.deleteChildren();
                        targetPage.setAvailableHeight();
                    } else {
                        while (!targetPage.checkAvailableHeight()) {
                            elementToMove.insertBefore(newNode.removeChild(newNode.lastChild), elementToMove.childNodes[0]);
                        }
                    }
                }

                //if in parsableNode then try to move more text and parsableNodes until it overflows, maybe a moveParsableElement
                if (isParseableNode) {
                    self.moveParseableChildNodes(targetPage, newNode, elementToMove);
                } else {

                    self.moveChildElements(elementToMove, targetPage, newNode, null, targetGroup);
                }
                return true;
            }
            if (elementToMove.childNodes.length > 0 && self.isForcePageBreak(elementToMove.childNodes[0])) {
                targetPage.pageBreak = true
                elementToMove.childNodes[0].classList.remove(self.options.forcePageBreakClass)
                return true
            }
        }

        elementToMove.parentNode.removeChild(elementToMove);
        if (self.options.convertImageTobase64) self.convertImageTobase64(newNode);
        --j;
    }
    return false;
};
Report.prototype.setPageInnerHeight = function (pageElement) {
    var self = this;
    self.pageInnerHeight = rp.utils.height(pageElement);


};

Report.prototype.splitPages = function (pageBreakPaperType) {
    var self = this;
    self.lastPage.setAvailableHeight();
    //window.scrollBy(0, -window.pageYOffset);
    var initAvailableHeight = self.lastPage.availableHeight;

    var newPage = self.insertPage(pageBreakPaperType);

    if (self.moveChildElements(self.lastPage.innerContent, newPage, newPage.innerContent, newPage.firstFooter)) {
        //safeguard infinite loop caused by mistakes in report design
        if (newPage.pageBreak) {
            self.splitPages(newPage.pageBreakPaperType)

        }
        self.lastPage.setAvailableHeight();


        if (initAvailableHeight === self.lastPage.availableHeight) {
            if (self.blankPageCt === 0) {
                self.blankPageCt++;
                console.log("Could not add any content to page, try removing force-page-break from first group or shrinking items so they can fit on a page");
            }
            else {
                console.log("Error: Infinite loop avoided, check report design for 'keep-together', 'full-page' or 'group-header' nodes that are too large to fit on one page");
                console.log("Error: Layout engine could not add content to the page container. Possible solutions:")
                console.log("- Increase page height by removing landscape or selecting a larger paper format.")
                console.log("- Shrink items so they can fit on a page, e.g. use max-height on images or canvas elements")
                console.log("- Check report design for 'keep-together' or 'group-header' nodes that are too large to fit on one page")
                console.log("- Add rp-contain class to element that is not able to fit on one page")
                console.log("Info: Element HTML:")
                console.log("<xmp>" + self.pages[self.pages.length - 2].insertingElementHTML + "</xmp>")
                return;
            }
        }
        self.splitPages();
    }
    else {

        self.lastPage.element.remove();
        self.lastPage = newPage;
        self.pages.pop(self.pages.length - 1);
        if (self.blankPageCt === 1) {
            self.lastPage.element.remove();
            self.pages.pop(self.pages.length - 1);
            self.lastPage = self.pages[self.pages.length - 1];

        }
    }

};

(function init() {
    var log = console.log
    rp.logs = [];
    console.log = function (msg) {
        rp.logs.push(msg)
        log.apply(console, arguments)

    }
})()

rp.createTarget = function (targetParentNode, childInsertBeforeNode) {
    var target = document.createElement('div');

    target.innerHTML =
        "<div id='previewPane' class='rp-target'>" +
        //<!--THIS TRIGGERS CUSTOM FONT LOAD AND ALLOWS FOR ACCURATE SIZING-->
        "<span style='visibility:hidden;'><!--first element --></span>" +
        "</div>";
    targetParentNode.insertBefore(target, childInsertBeforeNode);
    return target.childNodes[0];

}
rp.timeout = function (ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
rp.waitFor = async function (fn, args, ms, interval) {
    let timeoutCtr = 0
    const iterations = ms / interval

    while (timeoutCtr < iterations) {
        timeoutCtr++
        if (await fn(...args)) return true
        await rp.timeout(interval)
    }
    return false

}
rp.checkImages = async function (images) {
    console.log("checking " + images.length + " images...")
    for (var i = 0; i < images.length; i++) {
        if (!images[i].complete) {
            return false
        }
        else {
            //TODO log image url
            console.log(images[i].src)
        }
    }
    //TODO scroll to each image in the window
    window.scrollBy(0, document.body.scrollHeight)
    window.scrollTo(0, 0)

    return true
}
rp.getPagePaperTypes = function () {
    var self = this
    var report = self.reports[0]
    return report.pages.map(p => p.paperType)
}
rp.showPaperType = function (paperType) {
    var self = this
    var report = self.reports[0]
    report.pages.map(function (p) {
        if (p.paperType === paperType) {
            p.element.style.display = ''
        }
        else {
            p.element.style.display = 'none'
        }
    })
    report.options.orientation = null
    report.options.setPaperType(paperType)
    return report.options.chromeOptions()

}
rp.preview = async function (sources, opt) {
    var self = this
    self.reports = []
    const timeout = 10000

    console.log("responsive paper server side version: " + rp.version)
    // const images = document.getElementsByTagName("img")
    // if (await rp.waitFor(rp.checkImages, [images], timeout, 100)) { console.log("Images loaded") } else { console.log("Images not loaded in " + timeout + " ms") }
    //TODO if sources not an array , wrap in array.
    //Or remove multiple source support
    if (!sources) {
        sources = rp.utils.nodesToArray(document.querySelectorAll(".rp-page"));
    }

    if (!sources || sources.length === 0) {
        //todo if only one child element of body use that

        //todo wrap non script element content of body in div and use that
        sources = [];
        var wrapper = document.createElement('div');
        wrapper.classList.add("rp-page");
        window.document.body.appendChild(wrapper);

        Array.prototype.slice.call(window.document.body.childNodes, 0).map(function (node) {
            if (node !== wrapper) wrapper.appendChild(node);
        });
        //sources[0] = window.document.body.firstChild;
        return
        sources[0] = wrapper;
    }

    target = sources[0].parentNode;


    for (var i = 0; i < sources.length; i++) {
        rp.utils.clean(sources[i], true);
        //TODO insert into report container instead of preview
        //TODO apply rp-page css  to target

        var report = new Report(target, sources[i], opt);
        self.reports.push(report)
        //TODO scroll top

        //TODO extract generate and convert to promise

        //TODO Update report container position and left after generation

        //window.scrollBy(0, -window.pageYOffset);
    }

    target.style.overflow = "";
    target.style.maxHeight = "";
    //target.style.display = "none";
    //window.scrollBy(-window.pageXOffset, -window.pageYOffset);

};

rp.renderAsPDF = function (target, source, refresh) {
    //TODO renderAsPDF
};

rp.refresh = function (target, source) {
    //TODO refresh
};

rp.renderAsExcel = function (source, refresh) {
    //TODO renderAsExcel
};
//rp['utils'] = rp.utils;
}));

}());
